import { IMLParsedNode, INodeAttributeData, NodeAttributeMap } from 'types/models';
import { htmlValidator } from './htmlValidator';

/** CLIENT SIDE Streamlined access to the content generated by next.js in the ML component props */

/**
 * Return the page data, parsed from json if relevant
 * Guaranteed not null
 * @param pageData
 */
interface IMLNextBrowserUtils {
	getParsedPagedData<T>(pageData: string | object | null): T[];

	/**
	 * Returns an object with key-value entries for attributes that are valid for
	 * the provided node
	 * @param node
	 */
	extractNodeAttributes(node: IMLParsedNode): INodeAttributeData;
}

function toCamel(s: string): string {
	if (!s) {
		return "";
	}
	return s.replace(/([-][a-z])/ig, ($1) => {
	  return $1.toUpperCase()
		.replace('-', '');
	});
  };

function attrsToStyle(style?: string): NodeAttributeMap {
	const ret = {} as Record<string, string>;
	if (style && typeof style === "string") {
		const parts = style.split(';').map(s => s.trim());
		parts.forEach(part => {
			const ind = part.indexOf(':');
			if (ind > 0) {
				const key = part.substring(0, ind),
					value = part.substring(ind + 1).trim();
				if (key && value) {
					ret[toCamel(key)] = value;
				}
			}
		})
	}
	return ret;

}


class MLNextRuntimeUtils implements IMLNextBrowserUtils {
	public getParsedPagedData<T>(pageData: string | object | null): T[] {
		if (!pageData) {
			return [];
		}
		const parsedData =
			typeof pageData === 'string' ? JSON.parse(pageData) : pageData;

		return Array.isArray(parsedData) ? parsedData : [];
	}

	public extractNodeAttributes(node: IMLParsedNode): INodeAttributeData {
		const attributes = htmlValidator.filterAttributesFor(node?.type, node?.attributes);
		const style = attrsToStyle(attributes.style);
		delete attributes.style;
		return {
			attributes, style
		}
	}
}

export const mlNextBrowserUtils: IMLNextBrowserUtils = new MLNextRuntimeUtils();
